<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Add viewport meta tag for mobile responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Battle Mobile</title>
    <style>
        /* Ensure body takes full viewport height */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling */
            background-color: #2a2a2a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        /* Center the game container */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Portrait Game Container Dimensions */
        #game-container {
            position: relative;
            /* Portrait Aspect Ratio - Example: 9:16 */
            width: 450px;  /* Adjust width as needed */
            height: 800px; /* Adjust height as needed */
            max-width: 100%; /* Ensure it fits screen width */
            max-height: 100%; /* Ensure it fits screen height */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden; /* Keep game elements inside */
            background-color: #111; /* Background for the container itself */
        }
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }
        #game-title {
            color: #eee;
            font-size: 48px; /* Adjusted for portrait */
            margin-bottom: 30px; /* Adjusted spacing */
            text-shadow: 2px 2px 4px #000;
            text-align: center;
        }
        #peer-input {
            margin: 15px 0;
            padding: 14px;
            width: 80%; /* Wider input for portrait */
            font-size: 16px; /* Slightly smaller font for mobile */
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #eee;
            text-align: center; /* Center placeholder text */
        }
         #peer-input::placeholder {
            color: #999;
        }
        .button-container {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: center; /* Center buttons */
            margin-top: 20px;
            gap: 15px; /* Space between stacked buttons */
            width: 80%; /* Limit button container width */
        }
        .menu-button {
            padding: 15px 25px; /* Adjusted padding */
            font-size: 16px; /* Adjusted font size */
            border: none;
            border-radius: 5px;
            background-color: #5a8f5d;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            width: 100%; /* Make buttons take full width of container */
        }
        .menu-button:hover {
            background-color: #4d7a4f;
        }
         .menu-button:active {
            transform: translateY(1px);
             box-shadow: 0 2px 3px rgba(0,0,0,0.2);
        }
        /* Control Button at Bottom Center */
        #game-button {
            position: absolute;
            bottom: 20px; /* Position near bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 80px; /* Slightly smaller for mobile */
            height: 80px;
            border-radius: 50%;
            background-color: rgba(200, 200, 200, 0.4);
            border: 3px solid white;
            display: none;
            z-index: 5;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        #button-fill {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.6);
            transform: scale(0);
            transition: transform 0.1s ease-out;
        }
        /* Status Messages at Top Center */
        #status-message {
            position: absolute;
            top: 10px; /* Position near top */
            left: 0;
            width: 100%;
            text-align: center;
            color: #eee;
            font-size: 18px; /* Adjusted size */
            z-index: 4;
            display: none;
            text-shadow: 1px 1px 2px #000;
        }
        #opponent-status {
            position: absolute;
            top: 35px; /* Below main status */
            left: 0;
            width: 100%;
            text-align: center;
            color: #ffcc66;
            font-size: 16px; /* Adjusted size */
            z-index: 4;
            display: none;
             text-shadow: 1px 1px 2px #000;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1 id="game-title">Tank Battle Mobile</h1>
            <input type="text" id="peer-input" placeholder="Enter Room ID to join (leave empty to host)">
            <div class="button-container">
                <button id="host-button" class="menu-button">Host Game</button>
                <button id="join-button" class="menu-button">Join Game</button>
                <button id="training-button" class="menu-button">Training Mode</button>
            </div>
        </div>
        <div id="game-button">
            <div id="button-fill"></div>
        </div>
        <div id="status-message">You: 0 - Opponent: 0</div>
        <div id="opponent-status"></div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.3/peerjs.min.js"></script>
<script>
    // Game Configuration (Portrait Dimensions)
    const PORTRAIT_WIDTH = 450;
    const PORTRAIT_HEIGHT = 800;

    const config = {
        type: Phaser.AUTO,
        width: PORTRAIT_WIDTH, // Portrait width
        height: PORTRAIT_HEIGHT, // Portrait height
        parent: 'game-container',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false // Set to true for physics debugging
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        scale: { // Optional: Helps with fitting if parent container size is different
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH
        }
    };

    // Game state
    const gameState = {
        gameStarted: false,
        gameMode: null, // 'host', 'client', or 'training'
        playerScore: 0,
        opponentScore: 0,
        tanks: {},
        missiles: [],
        lastSyncTime: 0,
        connectionEstablished: false,
        buttonState: {
            isPressed: false,
            pressTime: 0
        },
        // Portrait Arena Dimensions - Leave space top/bottom
        arenaOffsetX: 25, // Left/Right padding
        arenaOffsetY: 50, // Top padding
        arenaWidth: PORTRAIT_WIDTH - 50, // Width minus padding * 2
        arenaHeight: PORTRAIT_HEIGHT - 150, // Height minus top padding and bottom button area
        aiUpdateTimer: 0,
        aiDecisionTime: 0,
        aiState: 'rotate',
        lerpFactor: 0.2 // Interpolation factor for opponent movement
    };

    // Peer connection
    let peer = null;
    let conn = null;
    let peerId = '';
    let remotePeerId = '';

    // Game objects
    let game; // Initialize later
    let controlButton;
    let buttonFill;
    let statusMessage;
    let opponentStatus;

    // Constants
    const TANK_ROTATION_SPEED = 90; // Slightly faster rotation might feel better on mobile
    const TANK_FORWARD_SPEED = 150; // Slightly faster speed
    const MISSILE_SPEED = 480; // Faster missile
    const MISSILE_LIFESPAN = 2200; // Shorter lifespan for smaller arena
    const SYNC_RATE = 50;
    const BUTTON_HOLD_THRESHOLD = 200;
    const AI_DETECTION_RADIUS = 300; // Adjust detection for portrait arena
    const TANK_DRAG = 0.97;
    const TANK_BOUNCE = 0.3;
    const MISSILE_BOUNCE = 0.5;

    // --- Asset Generation Functions (unchanged from previous version) ---
    
    
const tank_styles = {
  "classic": {
    canvas: { width: 40, height: 40 },
    body: {
      width: 34,
      height: 26,
      color: '#5a8f5d'
    },
    tracks: {
      width: 38,
      height: 6,
      color: '#4a4a4a'
    },
    turret: {
      radius: 8,
      offsetX: 20,
      color: '#4d7a4f'
    },
    barrel: {
      width: 18,
      height: 5,
      color: '#666666'
    }
  },
  "modern": {
    canvas: { width: 50, height: 50 },
    body: {
      width: 40,
      height: 30,
      color: '#7d9e7d'
    },
    tracks: {
      width: 45,
      height: 8,
      color: '#383838'
    },
    turret: {
      radius: 10,
      offsetX: 22,
      color: '#365e36'
    },
    barrel: {
      width: 22,
      height: 6,
      color: '#444444'
    }
  },
  "stealth": {
    canvas: { width: 40, height: 40 },
    body: {
      width: 32,
      height: 24,
      color: '#2e2e2e'
    },
    tracks: {
      width: 38,
      height: 4,
      color: '#1a1a1a'
    },
    turret: {
      radius: 7,
      offsetX: 17,
      color: '#1f1f1f'
    },
    barrel: {
      width: 16,
      height: 4,
      color: '#333333'
    }
  },
  "futuristic": {
    canvas: { width: 60, height: 60 },
    body: {
      width: 50,
      height: 40,
      color: '#8c92a1'
    },
    tracks: {
      width: 55,
      height: 10,
      color: '#6a6a6a'
    },
    turret: {
      radius: 12,
      offsetX: 25,
      color: '#5a7a8b'
    },
    barrel: {
      width: 24,
      height: 8,
      color: '#777777'
    }
  }
};
function generateTankDataURL(style = "stealth") {
  const tank_design = tank_styles[style] || tank_styles["classic"];
  const { canvas, body, tracks, turret, barrel } = tank_design;

  const canvasEl = document.createElement('canvas');
  canvasEl.width = canvas.width;
  canvasEl.height = canvas.height;
  const ctx = canvasEl.getContext('2d');

  const bodyX = (canvas.width - body.width) / 2;
  const bodyY = (canvas.height - body.height) / 2;

  // Draw tracks
  const trackX = (canvas.width - tracks.width) / 2;
  ctx.fillStyle = tracks.color;
  ctx.fillRect(trackX, bodyY - tracks.height, tracks.width, tracks.height); // Top
  ctx.fillRect(trackX, bodyY + body.height, tracks.width, tracks.height);   // Bottom

  // Draw body
  ctx.fillStyle = body.color;
  ctx.fillRect(bodyX, bodyY, body.width, body.height);

  // Draw turret
  const turretX = bodyX + turret.offsetX;
  const turretY = canvas.height / 2;
  ctx.fillStyle = turret.color;
  ctx.beginPath();
  ctx.arc(turretX, turretY, turret.radius, 0, Math.PI * 2);
  ctx.fill();

  // Draw barrel
  ctx.fillStyle = barrel.color;
  ctx.fillRect(turretX, turretY - barrel.height / 2, barrel.width, barrel.height);

  return canvasEl.toDataURL();
}
    
    
    function generateMissileDataURL() {
        const canvas = document.createElement('canvas'); canvas.width = 12; canvas.height = 6;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffcc66'; // Shell
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(10, 3); ctx.lineTo(0, 6); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ddaa44'; // Accent
        ctx.fillRect(0, 2, 3, 2);
        return canvas.toDataURL();
    }
    
    
    
    
    
    function generateExplosionDataURL() {
        const canvas = document.createElement('canvas'); canvas.width = 72; canvas.height = 72;
        const ctx = canvas.getContext('2d'); const centerX = 36; const centerY = 36; const maxRadius = 36;
        let gradient = ctx.createRadialGradient(centerX, centerY, maxRadius * 0.5, centerX, centerY, maxRadius); // Layer 1
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)'); gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.5)'); gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 72, 72);
        gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 0.6); // Layer 2
        gradient.addColorStop(0, 'rgba(255, 255, 150, 1)'); gradient.addColorStop(0.3, 'rgba(255, 255, 0, 1)'); gradient.addColorStop(0.8, 'rgba(255, 180, 0, 0)');
        ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(centerX, centerY, maxRadius * 0.7, 0, Math.PI * 2); ctx.fill();
        return canvas.toDataURL();
    }
    // --- End Asset Generation ---


    // Preload assets
    function preload() {
        this.load.image('tank', generateTankDataURL());
        this.load.image('missile', generateMissileDataURL());
        this.load.image('explosion', generateExplosionDataURL());
        // Sound loading placeholders (unchanged)
    }

    // Create game scene
    function create() {
        const self = this;
        // Set world bounds based on defined arena offset/size
        this.physics.world.setBounds(gameState.arenaOffsetX, gameState.arenaOffsetY, gameState.arenaWidth, gameState.arenaHeight);

        // Create arena visual background
        const arenaCenterX = gameState.arenaOffsetX + gameState.arenaWidth / 2;
        const arenaCenterY = gameState.arenaOffsetY + gameState.arenaHeight / 2;
        this.add.rectangle(arenaCenterX, arenaCenterY,
                           gameState.arenaWidth + 4, gameState.arenaHeight + 4, // Slightly larger for border effect
                           0x444444)
            .setStrokeStyle(2, 0x666666);

        this.add.rectangle(arenaCenterX, arenaCenterY,
                           gameState.arenaWidth, gameState.arenaHeight,
                           0x1e1e1e); // Darker arena floor

        // Initialize tank and missile groups
        this.tankGroup = this.physics.add.group();
        this.missileGroup = this.physics.add.group();

        // Set up collisions
        this.physics.add.collider(this.missileGroup, this.tankGroup, handleMissileHit, null, this);
        this.physics.add.collider(this.tankGroup, this.tankGroup);
        this.physics.add.collider(this.missileGroup, this.missileGroup);

        // Collide tanks and missiles with world bounds
        this.physics.world.on('worldbounds', (body) => {
            // Check if the body hitting the bounds is a missile and destroy it
            if (this.missileGroup.contains(body.gameObject) && body.gameObject.active) {
                 body.gameObject.destroy();
            }
            // Tanks hitting bounds will just stop due to setCollideWorldBounds(true)
        });


        // Game UI Setup
        controlButton = document.getElementById('game-button');
        buttonFill = document.getElementById('button-fill');
        statusMessage = document.getElementById('status-message');
        opponentStatus = document.getElementById('opponent-status');

        // Menu event listeners
        document.getElementById('host-button').addEventListener('click', () => {
            startGame('host');
        });
        document.getElementById('join-button').addEventListener('click', () => {
            const roomId = document.getElementById('peer-input').value.trim();
            if (roomId) {
                remotePeerId = roomId;
                startGame('client');
            } else {
                alert('Please enter a Room ID to join');
            }
        });
         document.getElementById('training-button').addEventListener('click', () => {
            startGame('training');
        });

        // Control button listeners - use touchstart/touchend for mobile primary
        controlButton.addEventListener('touchstart', handleButtonPress, { passive: false });
        controlButton.addEventListener('touchend', handleButtonRelease);
        // Add mouse events as fallback for desktop testing
        controlButton.addEventListener('mousedown', handleButtonPress);
        controlButton.addEventListener('mouseup', handleButtonRelease);
        controlButton.addEventListener('mouseleave', handleButtonRelease); // Stop if mouse leaves button

        // Key input for desktop testing (optional)
        this.input.keyboard.on('keydown-SPACE', handleButtonPress);
        this.input.keyboard.on('keyup-SPACE', handleButtonRelease);

        // Store scene reference in gameState
        gameState.scene = this;
    }

    // Start the game in specified mode
    function startGame(mode) {
        gameState.gameMode = mode;
        document.getElementById('start-screen').style.display = 'none';
        controlButton.style.display = 'block';
        statusMessage.style.display = 'block';

        // Create player tank (position/rotation for portrait)
        createTank('player', true);

        if (mode === 'host') {
            initializePeerConnection();
            updateScoreDisplay();
            opponentStatus.textContent = "Waiting for opponent...";
            opponentStatus.style.display = 'block';
        } else if (mode === 'client') {
            initializePeerConnection(remotePeerId);
            updateScoreDisplay();
            opponentStatus.textContent = "Connecting to host...";
            opponentStatus.style.display = 'block';
        } else if (mode === 'training') {
            // Create AI tank (position/rotation for portrait)
            createTank('ai', false);
            gameState.aiDecisionTime = Phaser.Math.Between(1000, 3000);
            updateScoreDisplay();
        }

        gameState.gameStarted = true;
    }

    // --- PeerJS Functions (initializePeerConnection, setupConnectionHandlers, handleIncomingData, sendTankState, sendFireEvent, sendScoreUpdate, sendHitConfirmation) ---
    // These functions remain largely the same logically. Ensure error handling and console logs are kept.
    // Added console logs for connect/disconnect events.
    // (Copying the robust versions from the previous iteration)

    function initializePeerConnection(hostId = null) {
        try {
            // Use a specific TURN/STUN server for potentially better reliability, especially on mobile networks (optional but recommended)
            // const peerConfig = {
            //     // debug: 2, // 0: none, 1: errors, 2: warnings+errors, 3: info+warnings+errors
            //     // iceServers: [
            //     //     { urls: 'stun:stun.l.google.com:19302' },
            //     //     // Add TURN server credentials here if you have them
            //     //     // { urls: 'turn:YOUR_TURN_SERVER_ADDRESS', username: 'YOUR_USERNAME', credential: 'YOUR_PASSWORD' }
            //     // ]
            // };
            // peer = new Peer(undefined, peerConfig); // Pass config if using custom servers

            peer = new Peer(); // Use PeerJS default signaling and STUN

            peer.on('open', id => {
                peerId = id;
                console.log('My peer ID is: ' + id);
                if (hostId) { // Client
                    console.log(`Attempting to connect to host: ${hostId}`);
                    conn = peer.connect(hostId, { reliable: true });
                    if (conn) {
                        setupConnectionHandlers(conn);
                    } else {
                        console.error("Connection object is null immediately after connect call.");
                        opponentStatus.textContent = "Failed to initiate connection.";
                        opponentStatus.style.display = 'block';
                    }
                } else { // Host
                    opponentStatus.textContent = `Room ID: ${id}`; // Shortened for mobile potentially
                    opponentStatus.style.display = 'block';
                    // Consider adding a "Copy ID" button here for easier sharing on mobile
                }
            });
            peer.on('error', err => {
                console.error('PeerJS error:', err);
                opponentStatus.textContent = `Connection Error: ${err.type}`;
                if (err.type === 'peer-unavailable') { opponentStatus.textContent += " (Room not found)"; }
                else if (err.type === 'network') { opponentStatus.textContent += " (Network issue)"; }
                else if (err.type === 'server-error') { opponentStatus.textContent += " (Server issue)"; }
                opponentStatus.style.display = 'block';
                gameState.connectionEstablished = false;
            });
            peer.on('connection', incomingConnection => {
                console.log('Incoming connection received');
                if (conn && conn.open) {
                    console.log('Already connected, rejecting new connection');
                    incomingConnection.close(); return;
                }
                conn = incomingConnection;
                setupConnectionHandlers(conn);
            });
            peer.on('disconnected', () => {
                console.log('Peer disconnected from the signaling server.');
                opponentStatus.textContent = "Signal server disconnect...";
                opponentStatus.style.display = 'block';
                gameState.connectionEstablished = false; // Reflect potential loss of connection pathway
                 // Maybe try to reconnect? peer.reconnect(); // Check PeerJS docs for usage
            });
            peer.on('close', () => {
                console.log('Peer connection closed completely.');
                gameState.connectionEstablished = false;
                opponentStatus.textContent = "Connection system closed.";
                opponentStatus.style.display = 'block';
            });
        } catch (error) {
            console.error("Error initializing PeerJS:", error);
            opponentStatus.textContent = "Failed to init connection.";
             opponentStatus.style.display = 'block';
        }
    }

    function setupConnectionHandlers(connection) {
        if (!connection) { console.error("setupConnectionHandlers: null connection."); return; }
        console.log(`Setting up handlers for connection with peer: ${connection.peer}`);
        connection.on('open', () => {
            console.log(`Connection opened with ${connection.peer}`);
            gameState.connectionEstablished = true;
            if (!gameState.tanks['opponent']) { createTank('opponent', false); }
            sendTankState(); sendScoreUpdate();
            opponentStatus.textContent = "Connected!";
            setTimeout(() => {
                if (opponentStatus.textContent === "Connected!") { opponentStatus.style.display = 'none'; }
            }, 2500);
        });
        connection.on('data', data => { handleIncomingData(data); });
        connection.on('close', () => {
            console.log(`Connection closed with ${connection.peer}`);
            gameState.connectionEstablished = false;
            opponentStatus.textContent = "Opponent disconnected.";
            opponentStatus.style.display = 'block';
            if (gameState.tanks['opponent']) { gameState.tanks['opponent'].destroy(); delete gameState.tanks['opponent']; }
            conn = null;
        });
        connection.on('error', err => {
            console.error(`Connection error with ${connection.peer}:`, err);
            opponentStatus.textContent = `Conn Error: ${err.type}`;
            opponentStatus.style.display = 'block';
            gameState.connectionEstablished = false;
            if (gameState.tanks['opponent']) { gameState.tanks['opponent'].destroy(); delete gameState.tanks['opponent']; }
            conn = null;
        });
    }

     function handleIncomingData(data) {
        if (data.type === 'state') {
            if (gameState.tanks['opponent'] && gameState.tanks['opponent'].active) { // Check active state
                const tank = gameState.tanks['opponent'];
                tank.targetX = data.x;
                tank.targetY = data.y;
                tank.targetRotation = data.rotation;
                // Direct updates for these might still be okay, or could also be smoothed
                tank.rotationDirection = data.rotationDirection;
                tank.isMoving = data.isMoving;
            }
        } else if (data.type === 'fire') {
            if (gameState.tanks['opponent'] && gameState.tanks['opponent'].active) {
                // Use opponent's *current interpolated* position/rotation for firing visual?
                // Or use the exact data sent? Using data sent is more accurate to opponent's action time.
                fireMissile('opponent', data.x, data.y, data.rotation);
            }
        } else if (data.type === 'score') {
            if(gameState.opponentScore !== data.playerScore || gameState.playerScore !== data.opponentScore) {
                gameState.opponentScore = data.playerScore;
                gameState.playerScore = data.opponentScore;
                updateScoreDisplay();
            }
        } else if (data.type === 'hit') {
            // Optional: Visually indicate opponent confirmed hit without changing score locally
            console.log(`Received hit confirmation for tank: ${data.tankId}`);
            if (gameState.tanks[data.tankId] && gameState.tanks[data.tankId].active) {
                 // Maybe a small visual effect on the hit tank?
            }
        }
    }

    function sendTankState() {
        if (conn && conn.open && gameState.tanks['player'] && gameState.tanks['player'].active) {
            const tank = gameState.tanks['player'];
            try {
                conn.send({ type: 'state', x: tank.x, y: tank.y, rotation: tank.rotation, rotationDirection: tank.rotationDirection, isMoving: tank.isMoving });
            } catch (error) { console.error("Send state error:", error); }
        }
    }

    function sendFireEvent(x, y, rotation) {
        if (conn && conn.open) {
            try {
                conn.send({ type: 'fire', x: x, y: y, rotation: rotation });
            } catch (error) { console.error("Send fire error:", error); }
        }
    }

    function sendScoreUpdate() {
        if (conn && conn.open) {
            try {
                conn.send({ type: 'score', playerScore: gameState.playerScore, opponentScore: gameState.opponentScore });
            } catch (error) { console.error("Send score error:", error); }
        }
    }

    function sendHitConfirmation(hitTankId) {
        if (conn && conn.open) {
            try {
                conn.send({ type: 'hit', tankId: hitTankId });
            } catch (error) { console.error("Send hit error:", error); }
        }
    }

    // --- End PeerJS Functions ---


    // Create tank sprite (Adjusted for Portrait Spawning)
    function createTank(id, isPlayer) {
        const scene = gameState.scene;
        let x, y, initialRotation;

        // Position tanks top/bottom for portrait
        if (isPlayer) {
            x = config.width / 2; // Center horizontally
            y = gameState.arenaOffsetY + gameState.arenaHeight - 50; // Near bottom
            initialRotation = Phaser.Math.DegToRad(-90); // Pointing UP
        } else { // Opponent or AI
            x = config.width / 2; // Center horizontally
            y = gameState.arenaOffsetY + 50; // Near top
            initialRotation = Phaser.Math.DegToRad(90); // Pointing DOWN
        }

        const tank = scene.tankGroup.create(x, y, 'tank');
        tank.setRotation(initialRotation); // Set initial rotation
        tank.setCollideWorldBounds(true);
        tank.setBounce(TANK_BOUNCE);
        tank.setDamping(true);
        tank.setDrag(TANK_DRAG);

        // Adjust physics body size/offset (same as before, relative to asset)
        tank.body.setSize(32, 38);
        tank.body.setOffset(4, 1); // Adjust offset based on the 40x40 canvas

        tank.id = id;
        tank.rotationDirection = 1; // Initial rotation direction (can be changed)
        tank.isMoving = false;

        // Interpolation Target Properties
        tank.targetX = x;
        tank.targetY = y;
        tank.targetRotation = initialRotation; // Set target rotation initially

        if (!isPlayer) {
            tank.setTint(0xff7777);
        } else {
             tank.setTint(0x99ccff); // Player tint
        }

        gameState.tanks[id] = tank;
        return tank;
    }

    // Fire missile from tank (Using velocityFromRotation)
    function fireMissile(tankId, x, y, rotation) {
        if (!gameState.tanks[tankId] || !gameState.tanks[tankId].active) return;

        const scene = gameState.scene;
        const barrelLength = 20; // Distance from center to barrel tip

        // Calculate missile start position based on tank's current rotation
        const startX = x + Math.cos(rotation) * barrelLength;
        const startY = y + Math.sin(rotation) * barrelLength;

        const missile = scene.missileGroup.create(startX, startY, 'missile');
        missile.setCollideWorldBounds(false); // Let world bounds event handle destruction
        missile.body.onWorldBounds = true; // Enable world bounds collision event
        missile.setBounce(MISSILE_BOUNCE);
        missile.body.setSize(10, 6);
        missile.setAngle(Phaser.Math.RadToDeg(rotation)); // Align visual rotation (missile points right)
        missile.tankId = tankId;

        // Set velocity using Phaser's helper function (expects rotation in radians, 0=right)
        scene.physics.velocityFromRotation(rotation, MISSILE_SPEED, missile.body.velocity);

        // Missile lifespan destroy
        scene.time.delayedCall(MISSILE_LIFESPAN, () => {
            if (missile.active) { missile.destroy(); }
        });

        // Sound placeholder (unchanged)

        return missile;
    }

    // Handle missile hitting a tank (Unchanged logic, uses new explosion)
    function handleMissileHit(missile, tank) {
        if (!missile.active || !tank.active || missile.tankId === tank.id) { return; }
        const scene = gameState.scene;

        const explosion = scene.add.image(missile.x, missile.y, 'explosion');
        explosion.setScale(0.1).setAlpha(0.8).setDepth(1);
        scene.tweens.add({
            targets: explosion, scale: 1.2, alpha: 0, duration: 400, ease: 'Expo.easeOut',
            onComplete: () => { explosion.destroy(); }
        });

        // Sound placeholders (unchanged)

        // Score and Network Update Logic (shooter handles score)
         if (missile.tankId === 'player' || missile.tankId === 'ai') {
            if (missile.tankId === 'player') { gameState.playerScore++; }
            else { gameState.opponentScore++; } // AI hit player
            updateScoreDisplay();
            if (gameState.gameMode === 'host' || gameState.gameMode === 'client') {
                sendScoreUpdate();
                sendHitConfirmation(tank.id);
            }
            respawnTank(tank);
        } else if (missile.tankId === 'opponent') { // Opponent missile hit us
             if (tank.id === 'player') {
                 respawnTank(tank); // Respawn player, score updated via network msg
             }
        }

        missile.destroy();
    }

    // Respawn tank at a random position (Uses portrait arena bounds)
    function respawnTank(tank) {
        const padding = 40; // Padding from arena edges
        const x = Phaser.Math.Between(gameState.arenaOffsetX + padding, gameState.arenaOffsetX + gameState.arenaWidth - padding);
        const y = Phaser.Math.Between(gameState.arenaOffsetY + padding, gameState.arenaOffsetY + gameState.arenaHeight - padding);

        // Determine respawn rotation based on who was hit (player respawns facing up, opponent/AI facing down)
        const respawnRotation = (tank.id === 'player') ? Phaser.Math.DegToRad(-90) : Phaser.Math.DegToRad(90);

        tank.setPosition(x, y);
        tank.setVelocity(0, 0);
        tank.setAngularVelocity(0);
        tank.setRotation(respawnRotation); // Set correct respawn rotation
        tank.rotationDirection = 1;
        tank.isMoving = false;

        if (tank.id === 'opponent') { // Reset opponent interpolation targets
            tank.targetX = x;
            tank.targetY = y;
            tank.targetRotation = respawnRotation;
        }

        // Invulnerability blink effect (unchanged)
        const scene = gameState.scene;
        tank.setAlpha(0.5).setActive(false);
        let blinks = 6;
        const blinkInterval = scene.time.addEvent({
            delay: 150,
            callback: () => {
                tank.setAlpha(tank.alpha === 1 ? 0.5 : 1); blinks--;
                if (blinks <= 0) { tank.setAlpha(1).setActive(true); blinkInterval.remove(); }
            },
            repeat: 11
        });
    }

    // Update score display (unchanged)
    function updateScoreDisplay() {
        const opponentLabel = gameState.gameMode === 'training' ? 'AI' : 'Opponent';
        statusMessage.textContent = `You: ${gameState.playerScore} - ${opponentLabel}: ${gameState.opponentScore}`;
    }

    // Handle button press (unchanged logic)
    function handleButtonPress(e) {
        if (e && e.preventDefault) e.preventDefault(); // Prevent default touch behavior (like scrolling)

        buttonFill.style.transform = 'scale(1)';
        setTimeout(() => { buttonFill.style.transform = 'scale(0.8)'; }, 100);

        gameState.buttonState.isPressed = true;
        gameState.buttonState.pressTime = Date.now();

        if (gameState.tanks['player'] && gameState.tanks['player'].active) {
            const tank = gameState.tanks['player'];
             if (!tank.isMoving) { // Switch rotation only if not holding to move
                tank.rotationDirection *= -1;
             }
        }
    }

    // Handle button release (Uses tank's current rotation for firing)
    function handleButtonRelease(e) {
        if (e && e.preventDefault) e.preventDefault();

        buttonFill.style.transform = 'scale(0)';
        const pressDuration = Date.now() - gameState.buttonState.pressTime;
        gameState.buttonState.isPressed = false;

        // Fire missile on tap
        if (pressDuration < BUTTON_HOLD_THRESHOLD && gameState.tanks['player'] && gameState.tanks['player'].active) {
            const tank = gameState.tanks['player'];
            // Fire using the tank's current rotation
            fireMissile('player', tank.x, tank.y, tank.rotation);
            // Send fire event to peer
            if ((gameState.gameMode === 'host' || gameState.gameMode === 'client') && conn && conn.open) {
                sendFireEvent(tank.x, tank.y, tank.rotation);
            }
        }
        // Stop moving sound placeholder (unchanged)
    }

    // Update AI tank (Adjusted for portrait logic and velocityFromRotation)
    function updateAI(delta) {
        if (!gameState.tanks['ai'] || !gameState.tanks['ai'].active || !gameState.tanks['player'] || !gameState.tanks['player'].active) return;

        const ai = gameState.tanks['ai'];
        const player = gameState.tanks['player'];
        gameState.aiUpdateTimer += delta;
        const distToPlayer = Phaser.Math.Distance.Between(ai.x, ai.y, player.x, player.y);

        // --- State Machine Logic ---
        if (distToPlayer < AI_DETECTION_RADIUS) { // --- Attack State ---
            const angleToPlayer = Phaser.Math.Angle.Between(ai.x, ai.y, player.x, player.y); // Angle from AI to Player (0 = right)
            const targetRotation = angleToPlayer; // AI should point directly towards player
            let angleDiff = Phaser.Math.Angle.Wrap(targetRotation - ai.rotation);
            const rotationTolerance = Phaser.Math.DegToRad(8); // Tighter tolerance

            // Aiming
            if (Math.abs(angleDiff) > rotationTolerance) {
                ai.rotationDirection = angleDiff > 0 ? 1 : -1;
                ai.isMoving = false; // Prioritize aiming
            } else { // Aimed
                ai.rotationDirection = 0; // Stop precise rotation

                // Firing logic (e.g., fire every 1.2 seconds when aimed)
                if (gameState.aiUpdateTimer > 1200) {
                    fireMissile('ai', ai.x, ai.y, ai.rotation);
                    gameState.aiUpdateTimer = 0;
                }

                // Movement logic (e.g., maintain distance, occasional strafe/backup)
                const idealDist = AI_DETECTION_RADIUS * 0.6;
                 if (distToPlayer > idealDist + 30 && Math.random() < 0.03) { // Move closer
                    ai.isMoving = true;
                    ai.rotationDirection = angleDiff > 0 ? 0.2 : -0.2; // Slight turn while moving
                    gameState.scene.time.delayedCall(500, () => { if (ai.active) ai.isMoving = false; });
                } else if (distToPlayer < idealDist - 50 && Math.random() < 0.03) { // Back up
                    ai.isMoving = true; // Set flag, reverse velocity in main update
                    ai.isBackingUp = true; // Use a flag for backup
                    gameState.scene.time.delayedCall(350, () => { if (ai.active) { ai.isMoving = false; ai.isBackingUp = false; }});
                } else {
                    ai.isMoving = false; // Hold position
                }
            }
        } else { // --- Patrol State ---
            if (gameState.aiUpdateTimer >= gameState.aiDecisionTime) {
                gameState.aiUpdateTimer = 0;
                const decision = Math.random();

                if (decision < 0.4) { // Change rotation direction
                    ai.rotationDirection = (Math.random() < 0.5) ? 1 : -1;
                    ai.isMoving = false;
                    gameState.aiDecisionTime = Phaser.Math.Between(1200, 3500); // Rotate duration
                } else { // Move forward
                    ai.isMoving = true;
                    ai.rotationDirection = (Math.random() - 0.5) * 0.5; // Gentle random curve
                    const moveDuration = Phaser.Math.Between(700, 1400);
                    gameState.aiDecisionTime = moveDuration + Phaser.Math.Between(800, 2000); // Move then pause
                    gameState.scene.time.delayedCall(moveDuration, () => { if (ai.active) ai.isMoving = false; });
                }
            }
        }
    }

    // Main update loop (Using velocityFromRotation, added AI backup logic)
    function update(time, delta) {
        if (!gameState.gameStarted || !gameState.scene) return; // Ensure scene exists

        const scene = gameState.scene; // Cache scene ref

        // --- Update Player Tank ---
        if (gameState.tanks['player'] && gameState.tanks['player'].active) {
            const tank = gameState.tanks['player'];
            let intendedMove = false;

            if (gameState.buttonState.isPressed) {
                const pressDuration = Date.now() - gameState.buttonState.pressTime;
                if (pressDuration >= BUTTON_HOLD_THRESHOLD) {
                    intendedMove = true;
                }
            }

            // Apply Rotation or Movement
            if (intendedMove) {
                tank.isMoving = true;
                // Use velocityFromRotation for forward movement based on current angle
                scene.physics.velocityFromRotation(tank.rotation, TANK_FORWARD_SPEED, tank.body.velocity);
                tank.setAngularVelocity(0); // Stop rotating when moving forward
                // Sound placeholder (start move loop)
            } else {
                tank.isMoving = false;
                tank.body.setVelocity(0, 0); // Stop linear movement
                tank.setAngularVelocity(TANK_ROTATION_SPEED * tank.rotationDirection); // Apply rotation
                // Sound placeholder (stop move loop)
            }
        }

        // --- Update Opponent Tank (Interpolation) ---
        if (gameState.tanks['opponent'] && gameState.tanks['opponent'].active) {
            const tank = gameState.tanks['opponent'];
            // Interpolate position
            tank.x = Phaser.Math.Linear(tank.x, tank.targetX, gameState.lerpFactor);
            tank.y = Phaser.Math.Linear(tank.y, tank.targetY, gameState.lerpFactor);
            // Interpolate rotation (shortest angle)
            tank.rotation = Phaser.Math.Angle.RotateTo(tank.rotation, tank.targetRotation, gameState.lerpFactor * 1.5); // Rotate smoothly
        }

        // --- Update AI Tank ---
        if (gameState.gameMode === 'training' && gameState.tanks['ai'] && gameState.tanks['ai'].active) {
            updateAI(delta); // Calculate AI decisions

            const ai = gameState.tanks['ai'];
            if (ai.isMoving) {
                 let speed = TANK_FORWARD_SPEED * 0.8; // AI slightly slower
                 // Handle backup movement
                 if (ai.isBackingUp === true) {
                     speed *= -0.7; // Move backward at reduced speed
                     ai.setAngularVelocity(0); // Don't rotate while backing straight up
                 } else {
                     // Apply slight curve during forward movement if rotationDirection is set
                     ai.setAngularVelocity(TANK_ROTATION_SPEED * ai.rotationDirection * 0.5);
                 }
                 // Use velocityFromRotation based on current AI rotation
                 scene.physics.velocityFromRotation(ai.rotation, speed, ai.body.velocity);
            } else {
                 ai.body.setVelocity(0, 0); // Stop linear movement
                 ai.setAngularVelocity(TANK_ROTATION_SPEED * ai.rotationDirection); // Apply rotation
            }
        }

        // --- Network Sync ---
        if ((gameState.gameMode === 'host' || gameState.gameMode === 'client') && conn && conn.open) {
            if (time - gameState.lastSyncTime >= SYNC_RATE) {
                sendTankState();
                gameState.lastSyncTime = time;
            }
        }
    }

    // Initialize Phaser game once the script loads
    window.onload = () => {
      s  game = new Phaser.Game(config);
    };

</script>

</body>
</html>